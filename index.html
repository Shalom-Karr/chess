<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess vs AI</title>
    <style>
        :root {
            --bg-color: #302e2b;
            --board-border: #5c4033;
            --white-sq: #eeeed2;
            --black-sq: #769656;
            --highlight: #baca44;
            --check: #e65858;
            --text-color: #ffffff;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            user-select: none;
        }

        h1 { margin: 0 0 10px 0; font-size: 2rem; }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 8px;
        }

        select, button {
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
        }

        button { background-color: #81b64c; color: white; font-weight: bold; }
        button:hover { background-color: #a3d160; }
        
        #status {
            margin-bottom: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            height: 25px;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 5px solid var(--board-border);
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            position: relative;
        }

        .white-sq { background-color: var(--white-sq); color: black; }
        .black-sq { background-color: var(--black-sq); color: black; }
        
        /* Highlights */
        .selected { background-color: var(--highlight) !important; opacity: 0.8; }
        .last-move { background-color: rgba(255, 255, 0, 0.4) !important; }
        .in-check { background-color: var(--check) !important; }

        .piece {
            cursor: pointer;
            z-index: 2;
            transition: transform 0.1s;
        }
        .piece:hover { transform: scale(1.1); }
        .piece.white { color: #fff; text-shadow: 0 0 2px #000; filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.5)); }
        .piece.black { color: #000; filter: drop-shadow(1px 1px 1px rgba(255,255,255,0.3)); }

        @media (max-width: 500px) {
            #board {
                grid-template-columns: repeat(8, 11vw);
                grid-template-rows: repeat(8, 11vw);
            }
            .square { width: 11vw; height: 11vw; font-size: 8vw; }
        }
    </style>
</head>
<body>

    <h1>Chess vs AI</h1>

    <div class="controls">
        <select id="difficulty">
            <option value="1">Easy (Random/Basic)</option>
            <option value="2" selected>Medium (Depth 2)</option>
            <option value="3">Hard (Depth 3)</option>
        </select>
        <button onclick="resetGame()">New Game</button>
    </div>

    <div id="status">Your Turn</div>
    <div id="board"></div>

    <script>
        // --- Game Constants & State ---
        const PIECES = {
            r: '♜', n: '♞', b: '♝', q: '♛', k: '♚', p: '♟', // Black
            R: '♜', N: '♞', B: '♝', Q: '♛', K: '♚', P: '♟'  // White
        };

        const VALUE_MAP = {
            p: 10, n: 30, b: 30, r: 50, q: 90, k: 900,
            P: -10, N: -30, B: -30, R: -50, Q: -90, K: -900,
            '.': 0
        };

        const INITIAL_BOARD = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        let board = [];
        let turn = 'white'; // Human is white
        let selectedSquare = null;
        let isGameOver = false;
        let lastMove = { from: null, to: null };

        // DOM Elements
        const boardEl = document.getElementById('board');
        const statusEl = document.getElementById('status');
        const difficultyEl = document.getElementById('difficulty');

        // --- Initialization ---
        function initGame() {
            board = JSON.parse(JSON.stringify(INITIAL_BOARD));
            turn = 'white';
            isGameOver = false;
            selectedSquare = null;
            lastMove = { from: null, to: null };
            updateStatus("Your Turn");
            renderBoard();
        }

        function resetGame() {
            initGame();
        }

        // --- Core Logic ---
        function getPieceColor(piece) {
            if (!piece) return null;
            return piece === piece.toUpperCase() ? 'white' : 'black';
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            // Check highlighting
            let kingInCheckPos = isKingInCheck(board, turn) ? findKing(board, turn) : null;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const sq = document.createElement('div');
                    sq.className = `square ${(r + c) % 2 === 0 ? 'white-sq' : 'black-sq'}`;
                    sq.dataset.r = r;
                    sq.dataset.c = c;

                    // Highlighting
                    if (selectedSquare && selectedSquare.r === r && selectedSquare.c === c) sq.classList.add('selected');
                    if ((lastMove.from && lastMove.from.r === r && lastMove.from.c === c) || 
                        (lastMove.to && lastMove.to.r === r && lastMove.to.c === c)) {
                        sq.classList.add('last-move');
                    }
                    if (kingInCheckPos && kingInCheckPos.r === r && kingInCheckPos.c === c) sq.classList.add('in-check');

                    const piece = board[r][c];
                    if (piece) {
                        const span = document.createElement('span');
                        span.className = `piece ${getPieceColor(piece)}`;
                        span.textContent = PIECES[piece];
                        sq.appendChild(span);
                    }
                    
                    sq.addEventListener('click', () => onSquareClick(r, c));
                    boardEl.appendChild(sq);
                }
            }
        }

        function onSquareClick(r, c) {
            if (isGameOver || turn !== 'white') return; // Human only moves on white

            const clickedPiece = board[r][c];
            const clickedColor = getPieceColor(clickedPiece);

            // Select Piece
            if (!selectedSquare) {
                if (clickedColor === 'white') {
                    selectedSquare = { r, c };
                    renderBoard();
                }
                return;
            }

            // Change Selection
            if (clickedColor === 'white') {
                selectedSquare = { r, c };
                renderBoard();
                return;
            }

            // Attempt Move
            const fromR = selectedSquare.r;
            const fromC = selectedSquare.c;

            if (isValidMove(board, fromR, fromC, r, c, 'white')) {
                executeMove(board, fromR, fromC, r, c);
                lastMove = { from: {r: fromR, c: fromC}, to: {r, c} };
                turn = 'black';
                selectedSquare = null;
                renderBoard();
                
                checkGameState();
                
                if (!isGameOver) {
                    updateStatus("Computer is thinking...");
                    setTimeout(makeComputerMove, 100);
                }
            } else {
                selectedSquare = null;
                renderBoard();
            }
        }

        // --- Move Validation Logic ---

        function isValidMove(currentBoard, r1, c1, r2, c2, color) {
            const piece = currentBoard[r1][c1];
            if (!piece) return false;
            
            // 1. Basic Geometry
            if (!checkGeometry(currentBoard, r1, c1, r2, c2, piece)) return false;

            // 2. Path Clear (except knight)
            if (piece.toLowerCase() !== 'n' && !isPathClear(currentBoard, r1, c1, r2, c2)) return false;

            // 3. Does it leave King in check?
            const nextBoard = simulateMove(currentBoard, r1, c1, r2, c2);
            if (isKingInCheck(nextBoard, color)) return false;

            return true;
        }

        function checkGeometry(bd, r1, c1, r2, c2, piece) {
            const type = piece.toLowerCase();
            const color = getPieceColor(piece);
            const target = bd[r2][c2];
            const targetColor = getPieceColor(target);
            const dx = Math.abs(c2 - c1);
            const dy = Math.abs(r2 - r1);

            if (targetColor === color) return false; // Can't capture own

            if (type === 'p') {
                const dir = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                // Move 1
                if (c1 === c2 && r2 === r1 + dir && !target) return true;
                // Move 2
                if (c1 === c2 && r1 === startRow && r2 === r1 + 2 * dir && !target && !bd[r1 + dir][c1]) return true;
                // Capture
                if (Math.abs(c1 - c2) === 1 && r2 === r1 + dir && target) return true;
                return false;
            }
            if (type === 'r') return dx === 0 || dy === 0;
            if (type === 'b') return dx === dy;
            if (type === 'q') return dx === 0 || dy === 0 || dx === dy;
            if (type === 'n') return (dx === 2 && dy === 1) || (dx === 1 && dy === 2);
            if (type === 'k') return dx <= 1 && dy <= 1;
            return false;
        }

        function isPathClear(bd, r1, c1, r2, c2) {
            const dx = Math.sign(c2 - c1);
            const dy = Math.sign(r2 - r1);
            let x = c1 + dx;
            let y = r1 + dy;
            while (x !== c2 || y !== r2) {
                if (bd[y][x]) return false;
                x += dx;
                y += dy;
            }
            return true;
        }

        function executeMove(bd, r1, c1, r2, c2) {
            const piece = bd[r1][c1];
            bd[r2][c2] = piece;
            bd[r1][c1] = '';
            // Promotion
            if (piece === 'P' && r2 === 0) bd[r2][c2] = 'Q';
            if (piece === 'p' && r2 === 7) bd[r2][c2] = 'q';
        }

        function simulateMove(bd, r1, c1, r2, c2) {
            const newBd = bd.map(row => [...row]); // Deep copy
            executeMove(newBd, r1, c1, r2, c2);
            return newBd;
        }

        // --- Check / Checkmate ---
        function findKing(bd, color) {
            const k = color === 'white' ? 'K' : 'k';
            for (let r = 0; r < 8; r++)
                for (let c = 0; c < 8; c++)
                    if (bd[r][c] === k) return { r, c };
            return null;
        }

        function isKingInCheck(bd, color) {
            const kPos = findKing(bd, color);
            if (!kPos) return true; // King missing? technically check
            const enemyColor = color === 'white' ? 'black' : 'white';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = bd[r][c];
                    if (p && getPieceColor(p) === enemyColor) {
                        // Check geometry only (cheaper), then path
                        if (checkGeometry(bd, r, c, kPos.r, kPos.c, p)) {
                            if (p.toLowerCase() === 'n' || isPathClear(bd, r, c, kPos.r, kPos.c)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function getAllLegalMoves(bd, color) {
            const moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (getPieceColor(bd[r][c]) === color) {
                        // Optimization: Check likely moves instead of 64 squares
                        // For simplicity in this file, we scan board, but optimize types
                        for (let tr = 0; tr < 8; tr++) {
                            for (let tc = 0; tc < 8; tc++) {
                                if (isValidMove(bd, r, c, tr, tc, color)) {
                                    moves.push({ from: {r, c}, to: {r: tr, c: tc} });
                                }
                            }
                        }
                    }
                }
            }
            return moves;
        }

        function checkGameState() {
            const moves = getAllLegalMoves(board, turn);
            if (moves.length === 0) {
                isGameOver = true;
                if (isKingInCheck(board, turn)) {
                    updateStatus(`Checkmate! ${turn === 'white' ? 'Black' : 'White'} wins!`);
                } else {
                    updateStatus("Stalemate! It's a draw.");
                }
            } else if (isKingInCheck(board, turn)) {
                updateStatus("Check!");
            } else {
                updateStatus(turn === 'white' ? "Your Turn" : "Computer Thinking...");
            }
        }

        function updateStatus(msg) {
            statusEl.textContent = msg;
        }

        // --- AI (Minimax with Alpha-Beta) ---

        function makeComputerMove() {
            if (isGameOver) return;

            const depth = parseInt(difficultyEl.value);
            // Count pieces to decide if endgame (optional optimization, skipped for brevity)
            
            const bestMove = minimaxRoot(depth, board, true);
            
            if (bestMove) {
                executeMove(board, bestMove.from.r, bestMove.from.c, bestMove.to.r, bestMove.to.c);
                lastMove = bestMove;
                turn = 'white';
                renderBoard();
                checkGameState();
            }
        }

        function evaluateBoard(bd) {
            let score = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = bd[r][c];
                    if (p) {
                        score += VALUE_MAP[p];
                        // Simple positional bonus (center control)
                        if ((r===3 || r===4) && (c===3 || c===4)) {
                            score += (getPieceColor(p) === 'black' ? 2 : -2);
                        }
                    }
                }
            }
            return score; // Positive = Black Adv (since we mapped Black as positive in VALUE_MAP... wait)
            // Correction: VALUE_MAP has Black positive? 
            // Standard: White positive. Let's fix VALUE_MAP or logic.
            // My VALUE_MAP: p=10 (Black), P=-10 (White). 
            // So Higher Score = Better for Black.
        }

        function minimaxRoot(depth, bd, isMaximizing) {
            // isMaximizing for Black means we want highest score (Positive)
            const moves = getAllLegalMoves(bd, 'black');
            let bestMove = null;
            let bestValue = -Infinity;

            // Sort moves to improve pruning (captures first) - rudimentary
            // moves.sort(() => 0.5 - Math.random()); // Random shuffle for variety in easy mode

            for (let i = 0; i < moves.length; i++) {
                const move = moves[i];
                const newBd = simulateMove(bd, move.from.r, move.from.c, move.to.r, move.to.c);
                const value = minimax(depth - 1, newBd, -Infinity, Infinity, false);
                
                if (value > bestValue) {
                    bestValue = value;
                    bestMove = move;
                }
            }
            return bestMove;
        }

        function minimax(depth, bd, alpha, beta, isMaximizing) {
            if (depth === 0) {
                return evaluateBoard(bd);
            }

            const moves = getAllLegalMoves(bd, isMaximizing ? 'black' : 'white');
            
            if (moves.length === 0) {
                if (isKingInCheck(bd, isMaximizing ? 'black' : 'white')) {
                    return isMaximizing ? -10000 : 10000; // Checkmate
                }
                return 0; // Stalemate
            }

            if (isMaximizing) { // Black's turn (maximize score)
                let maxEval = -Infinity;
                for (let move of moves) {
                    const newBd = simulateMove(bd, move.from.r, move.from.c, move.to.r, move.to.c);
                    const eval = minimax(depth - 1, newBd, alpha, beta, false);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else { // White's turn (minimize score)
                let minEval = Infinity;
                for (let move of moves) {
                    const newBd = simulateMove(bd, move.from.r, move.from.c, move.to.r, move.to.c);
                    const eval = minimax(depth - 1, newBd, alpha, beta, true);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        // Start
        initGame();

    </script>
</body>
</html>
